



### 2、进程同步

> 为什么要引入进程同步？

在多道程序环境下，进程是并发执行的，不同进程之间寻存在着不同的制约关系，**为了协调进程之间的制约关系，引入了进程同步的概念**。进程同步涉及到以下概念：

- 临界资源：一次仅允许一个进程使用的资源；访问临界资源的那段代码叫【临界区】
- 同步：同步是指协调进程间的工作次序关系、传递信息所产生的制约关系；
- 互斥：互斥是指当一个进程持有临界资源的时候，其他进程必须等待；当持有临界资源的进程退出临界区后，其他进程才能使用临界资源。

> 同步机制需要注意哪些准则？

1）空闲让进：

2）忙则等待：

3）有限等待：

4）让权等待：

#### 2.1、实现临界区互斥

> 实现临界区互斥有哪些方法？

实现进程间在临界区**互斥**的方法可以分为软件方法和硬件方法

- 软件实现方法
  1. 单标志算法
  2. 双标志法先检查
  3. 双标志法后检查
  4. 皮特森算法
- 硬件实现方法
  1. 中断屏蔽
  2. 硬件指令：TestAndSet或Swap

#### 2.2、信号量

> 操作系统什么机制可以解决互斥和同步问题？

- 信号量：提供PV操作的原语。P操作理解为获取锁，V操作理解为释放锁。
  1. 整型信号量：不断尝试获取信号量，采用【忙等待】，不会【让权等待】
  2. 记录型信号量：获取不到信号量的进程被放入到等待队列，让出CPU，不会忙等待。

> 使用信号量如何实现同步、互斥？

将信号量的初值设为1，同于【互斥】的时候，信号量就相当于一把锁；

> 原语是如何实现的？

原语是完成某种功能且不可分割、不可被中断的操作序列，通常由硬件实现；也可用软件实现，如中断屏蔽。

#### 2.3 管程

> 什么是管程？

信号量的PV操作都需要程序员自己实现，操作不当就容易死锁，【管程】可以理解为，是对共享资源和操作共享资源的封装，提供操作共享资源的接口，用于进程间的同步和互斥。

> 条件变量是不是管程？条件变量和信号量有什么区别？

条件变量包含在管程的实现当中，条件变量不等于管程。

管程将条件变量定义为：进程进入管程后被阻塞，阻塞原因就是条件变量，条件变量不满足，所以进程被阻塞、进入等待。条件变量不是一个实际存在的变量。

管程内部可以设置多个条件变量，每个条件变量仅实现为一个等待队列x，用于记录阻塞在该条件变量上的所有进程；条件变量只有2种操作：x.wait 和 x.signal。

条件变量和信号量相比：信号量是“有值的”，表示剩余资源数；而条件变量是没有值的，条件变量就是一个等待队列。管程中用【共享数据结构】来表示剩余资源数，不一定是信号量。

#### 2.4 经典同步问题

> 有哪些经典的同步问题？

- 生产者-消费者问题

- 读者-写者问题

  1. 读者优先
  2. 写者优先

- 哲学家进餐问题：如何避免死锁和饥饿

  - 同时拿起2根筷子，即左右2个筷子都可以用的时候才拿起

  - 按照某种规则拿筷子，避免饥饿和死锁
    1. 对哲学家进行编号，要求奇数号的哲学家先拿左边的筷子，再拿右边的筷子；同时要求偶数号的哲学家先拿右边的筷子，再拿左边的筷子。
    2. 至多允许n-1位哲学家同时进餐

  

- 吸烟者问题

### 3、死锁

#### 3.1 死锁的原因和条件？

> 什么是死锁？产生死锁的原因是什么？死锁的必要条件是什么？

所谓死锁，是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力推动，这些进程都将无法向前推进。

产生死锁的原因：

- 系统资源的竞争：**资源有限且不可抢占**【这是大前提】，可抢占的资源竞争是不会陷入死锁的；
- 进程推进顺序非法：进程运行过程，请求和释放资源的顺序不当也会导致死锁；

产生死锁的必要条件（**同时满足以下4个**）：

1. **互斥的条件**：资源有限，且是互斥的；
2. **不可抢占的条件**：进程获取资源之后，除非使用完主动释放，否则不能被其他进程夺走；
3. **请求并保持的条件**：进程持有了至少一个资源，然后又请求其他新的资源，而新的资源已经被其他进程持有，进程阻塞且不释放已占有的资源；
4. **循环等待的条件**：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下个进程所请求。

循环等待只是死锁的必要条件

#### 3.2 如何预防死锁？

> 如何预防死锁？从死锁的4个必要条件出发，要预防死锁，就要破坏4个必要条件之一

通过设置某些限制条件，破坏死锁的4个必要条件的一个或几个，从而防止发生死锁。

1. 破坏互斥条件：系统资源一般是无法同时共享的，所以破坏互斥条件是【不可行的】；
2. 破坏不可抢占条件：当一个持有某些不可抢占资源的进程请求新的资源而得不到时，进程释放掉持有的全部资源，待以后重新申请。【导致进程前部分工作实效；增加系统开销，降低系统吞吐量】
3. 破坏请求并保持条件：预先静态分配资源，进程在运行之前一次性申请需要的全部资源，资源没有全部满足时不运行；【可能导致饥饿】，可能个别资源被长期占用，其他需要该资源的进程长期无法运行。
4. 破坏循环等待条件：为每一种资源编号，规定进程必须按照编号递增的顺序来请求资源，同类资源一次性申请完。即进程申请R1类资源，下次只能申请R2类资源，无法重复申请R1类资源；

#### 3.3 如何避免死锁？

> 死锁避免策略是如何避免发生死锁的？ 死锁避免和死锁预防有什么区别？

死锁避免同样属于事先预防策略，但与【死锁预防】不同的是，【死锁避免】并非通过破坏【死锁必要条件】，而是在资源分配之前，检查是否会陷入【系统不安全状态】来决定此次分配能不能进行，从而避免死锁。

【安全状态】是指系统能按照某种【进程推进顺序】（P1, P2, P3,,,,Pn）为每个进程Pi分配所需资源，直到满足每个进程对资源的最大需求，使每个进程都能顺利运行完成。此时的（P1, P2, P3,,,,Pn）称为【安全序列】。如果无法找到一个【安全序列】，那么系统处于【不安全状态】

所以，是否存在一个【安全序列】是检查系统是否安全的充分必要条件。

> 著名的死锁避免算法——银行家算法



#### 3.4 如何检测并解除死锁？



