## 重构：改善既有代码的设计

### 1、重构的第一步

- 代码组织/结构要清晰

思考：如果需求发生变化，代码结构会不会劣化？可维护性？

常见场景

1. if else 不断增加或者嵌套； if 条件不断膨胀

2. switch 块 不断膨胀



- 依赖于测试集进行重构

重构前，确保有一套可靠的测试集可以检验重构后的代码的正确性、稳定性。

重构过程可能引入性能问题，如果重构引入了性能损耗，先完成重构，再做性能优化，有了重构后的清晰结构，再做优化也容易很多。

- 提炼函数：什么情况下应该把逻辑代码抽象为函数？

- 多态：子类型过多，能不能考虑利用【多态】进行重构优化？
- 



### 2、重构的原则

> 什么是重构？

重构，对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

重构是逐步完成的，任何一个中间状态都能保持代码能够工作；如果重构过程代码处于不可用状态，那么基本上可以上做的不是重构。

- 严格区分添加新功能和重构
  1. 添加新功能：一定不修改既有代码结构
  2. 重构：一只管调整代码结构，一定不要添加新功能

> 为什么重构？

重构的目的：

- 重构改进软件的设计
- 重构使软件更容易理解
- 重构有助于发现bug
- 重构提升编程效率：因为重构后的代码结构清晰，模块分化清楚，添加新功能更容易。

> 什么时候需要重构？

事不过三！如果类似的一件事重复做了三次，那就该考虑重构了。

- 最佳时间就是在添加新功能之前
- 代码结构混乱，难以理解
- 代码瘦身，清理代码垃圾，去掉不必要的逻辑
- 在代码review的过程中指出问题、指导重构

如果重写比重构还容易，那就别重构了，干脆重写。

> 重构会面临哪些问题？

- 延缓新功能的开发：新功能的开发必须建立在重构之后的代码上，不得不延缓新功能开发；但是重构是为了更高效地开发新功能。
- 代码所有权：重构不仅会影响模块内部，还会影响到使用该模块的系统其他部分，尤其是重构过程修改函数名，可导致其他模块的调用失效，为此采用 [duplicated]版本和新版本共存。
- 重构和新功能开发采用不同分支：随着独立开发的时间加长，分支合并的难度越来越大。
- 测试驱动重构，自测试的代码来测试重构的结果。



### 3、代码的坏味道

1. Bad Name：糟糕的命名，影响可读性
2. Duplicated Code：重复的代码、重构的代码结构，设法合二为一
3. Long Function：函数体过长，设法分解函数、提炼函数；条件表达式和循环常常是提炼的信号；
4. Long Parameter List：函数的参数列表过长，将若干参数合成类或结构体，缩短参数列表；
5. Global Data：全局变量泛滥，将全局变量用函数封装起来，避免污染全局空间；
6. Multable Data：可变数据，
7. Divergent Change：发散式变化，某个模块因为不同的原因在不同方向上发生变化
8. Shotgun Surgery：霰弹式变化，遇到某种变化，都必须在许多不同的地方做出许多的小修改
9. Feature Envy：
10. Data Clumps：数据泥团，
11. Primitive Obsession：基本类型偏执
12. Repeated Switches：
13. Loops：
14. Lazy Element：
15. Speculative G=enerality：
16. Temporary Field：
17. Message Chains：
18. Middle Man：
19. Insider Trading：
20. Large Class：
21. Alternative Classes with Diffenrent Interfaces：
22. Pure Data Class：
23. Refused Bequest
24. Comments
25. 

