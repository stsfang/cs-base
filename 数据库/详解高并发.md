

## MySql



### S1. MyISam 和 InnoDB的区别

#### 1）MyISam是v5.1前的默认引擎

- 支持全文检索、压缩、空间函数
- 不支持事务
- 不支持行级锁
- 不支持外键

#### 2）InnoDB基于聚簇索引

- 支持事务
- 支持外键
- 支持MVCC，Multi-Version Concurrency Control，多版本并发控制

### S2.锁

#### 1）从使用上分为共享锁和排他锁

- 共享锁，也叫 读锁，共享时只能读不能写
- 排他锁，也叫 写锁，阻塞其他的写和读

#### 2）从粒度上分为表锁和行锁

- 表锁：顾名思义，使用表锁时对整张表加锁，阻塞其他用户对该表的所有读写操作，如，alter修改表结构时就会获取表锁
- 行锁：行锁即仅作用于某一行的锁，分锁又分为悲观锁和乐观锁
  - 悲观锁
  - 乐观锁

### S3. MVCC

多版本并发控制，实际是保存了数据在某个时间的快照

- MVCC原理：查找创建版本小于或等于当前事务版本，删除版本为空或者大于当前事务版本；保证事务的隔离性

- 幻读：

### S4. 事务

#### 1）事务基本特性ACID分别是

- Atomicity 原子性
- Consistency 一致性
- Insolation 隔离性
- Durability

#### 2）如何保证或实现ACID

- 原子性：由 `undo log` 日志保证，事务撤销时，根据undo log回滚已经执行的SQL
- 一致性：由代码层面保证
- 隔离性：由MVCC 多版本并发控制来保证
- 持久性：由内存+`redo log`来保证；修改同时在内存和redo log记录本次操作，事务提交时通过`redo log`刷盘，宕机时从`redo log`恢复。

#### 3）隔离级别

- read uncommit 读未提交：
- read commit 读已提交：
- repeatable read 可重复读：
- serializable 串行：



### S5.分库分表

分库分表，要结合业务需求，分析当前数据库的性能瓶颈，

- IO瓶颈：
  - 磁盘IO瓶颈：**热点数据太多**，数据库缓存不下（库太大） ==> 分库；或，单次查询时产生大量IO（表太大）；==> **垂直分表**；（注，由热点数据导致的垂直分表，一般是将热点数据相关字段单独成表）
  - 网络IO瓶颈：网络请求太多，带宽不足，单个数据库无法及时响应 ==>  分库；
- CPU瓶颈
  - SQL条件查询无索引导致 ==> 建立合适的索引来优化查询；
  - 单表数据量太大导致查询扫描的行太多，SQL效率低 ==> **水平分表**；

不管是分库还是分表，都有两种方式，垂直划分和水平划分。垂直划分是划分原库或原表的结构，如，数据库DB包括表A，表B，表C，垂直划分DB库，将表A，表B，表C分别单独作为数据库；水平划分是分化原库或原表的规模，如原表9个亿的行记录，分为1024张表，每张表的数据100万左右。

#### 1）垂直分库

以表为单位，按照业务归属，将不同的表划分到不同的库。例如现在的微服务：订单、用户、商品、库存、支付等，将原数据库按照微服务，垂直分化为每个微服务对应一个数据库。

- 系统绝对并发量上来，将业务模块独立抽象出来，形成单个数据库服务。

#### 2）垂直分表

垂直分表，一般是因为表的字段太多，单行太大，导致热点数据所在行记录缓存少；将热点字段，非热点数据单独拆分；这样一来，更多热点数据所在的行记录能够得到缓存；减少随机读IO。

- 系统绝对并发量没有上来，只是为了解决热点数据缓存问题
- 拆分之后，想获取全部数据就需要关联2个表，但别用join 来连接查询 （不要在数据库做连接，这个不理解），应该放到业务层代码做文章，分别获取主表和扩展表的数据然后用关联字段得到全部数据。（而是在业务层代码里关联）

#### 3）水平分库

按照一定策略，如某个字段为依据，一个库中的数据拆分到多个库；

- 库的结构一样，即组成库的表是一样的；库的数据没有交集；全部库的并集就是全量数据
- 系统的绝对并发量上来了，但是还没有明显的业务划分可以做垂直分库，所以才水平分库

#### 4）水平分表

以字段为依据，按照某个策略，将表的数据拆分到多个表。由于水平分表是划分表的规模，所以需要决定用什么字段来作为分表字段（**shareding_key**），即哪些行记录应该划分到哪个表，类似hash。

- 每个表的结构一样；表的数据没有交集；全部表数据的并集是全量数据
- 系统绝对并发量没上来，只是单表的数据量太多（索引文件太大？），单次SQL执行效率低，CPU负担重

#### 5）分表后如何保证ID的唯一性

由于ID自增等的唯一性是基于表而言，分表之后，后来的插入记录可能破坏了原来ID的唯一性，目前有如下规避方法可以考虑：

- 分表时取模，不同表插入时设置自增步长（常用于hash策略）。分表的时候，如 ID % num_tables 决定当前行记录分到哪个表Table，该表插入的时候，ID自增步长为num_tables。
- 全局分布式ID，将原来的ID再插入的时候替换为全局分布式ID，可以保证ID的唯一性（感觉有点问题）
- 分表后每张表单独新增一个字段作为唯一主键（涉及到修改SQL文件），弃用原来的主键ID

#### 6）分表后非sharding_key的查询怎么处理？

（非shareding_key无法确定在哪个表）

- 映射法：建立 非sharding_key 与 sharding_key 的映射关系表，将非sharding_key转为shareding_key
- 其他？

#### 总结

1. 分析瓶颈，合理拆分，分库还是分表，水平还是垂直
2. 选sharding_key，同时考虑拆分均匀，和，非sharding key 的查询
3. 满足条件，拆分简单

参考

1. https://www.jianshu.com/p/698ba1b02522
2. 

### s6. 主从数据库

1）主从数据库如何同步

2）主从延迟如何解决









